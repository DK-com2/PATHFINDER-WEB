<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="theme-color" content="#3498db">
    <meta name="description" content="Google Timeline ãƒ‡ãƒ¼ã‚¿ã®åœ°å›³å¯è¦–åŒ–">
    <title>Pathfinder - åœ°å›³è¡¨ç¤º</title>

    <!-- Deck.gl CDN -->
    <script src="https://unpkg.com/deck.gl@^8.9.0/dist.min.js"></script>

    <!-- noUiSlider CDN -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.0/nouislider.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/15.7.0/nouislider.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Helvetica', 'Arial', sans-serif;
            background: #f5f5f5;
        }

        #container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #header {
            background: white;
            padding: 10px 15px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        #map {
            flex: 1;
            position: relative;
        }

        #info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            left: 10px;
            background: white;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            z-index: 1000;
        }

        @media (min-width: 640px) {
            #info-panel {
                left: auto;
                min-width: 200px;
            }
        }

        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1001;
            display: none;
        }

        .loading {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .spinner {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .legend {
            margin-top: 10px;
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin: 3px 0;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 10px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            touch-action: manipulation;
            min-height: 44px;
            width: 100%;
            margin-bottom: 5px;
        }

        .btn:hover {
            background: #2980b9;
        }

        @media (min-width: 640px) {
            .btn {
                width: auto;
                margin-bottom: 0;
                margin-right: 5px;
                min-height: auto;
                padding: 8px 16px;
            }
        }

        .btn-secondary {
            background: #95a5a6;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .attribution {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            color: #666;
            z-index: 1000;
        }

        /* æŠ˜ã‚ŠãŸãŸã¿æ©Ÿèƒ½ */
        .collapse-btn {
            display: none;
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-bottom: 10px;
            width: 100%;
            touch-action: manipulation;
        }

        .collapse-btn:hover {
            background: #2980b9;
        }

        .panel-content {
            transition: max-height 0.3s ease-out, opacity 0.3s ease-out;
            overflow: hidden;
        }

        .panel-collapsed .panel-content {
            max-height: 0;
            opacity: 0;
        }

        /* Time Filter Styles */
        #time-filter-container {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #eee;
        }

        .filter-header {
            font-size: 12px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #date-range-display {
            font-size: 11px;
            color: #3498db;
            font-weight: bold;
        }

        #time-slider {
            height: 10px;
            margin: 0 10px 15px 10px;
        }

        .noUi-connect {
            background: #3498db;
        }

        .noUi-handle {
            height: 18px !important;
            width: 18px !important;
            top: -5px !important;
            right: -9px !important;
            border-radius: 50%;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            cursor: pointer;
        }

        .noUi-handle:before, .noUi-handle:after {
            display: none;
        }

        .preset-buttons {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }

        .preset-btn {
            flex: 1;
            padding: 4px;
            font-size: 10px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            color: #555;
            transition: all 0.2s;
        }

        .preset-btn:hover {
            background: #e0e0e0;
        }

        .preset-btn.active {
            background: #3498db;
            color: white;
            border-color: #2980b9;
        }

        @media (max-width: 640px) {
            .collapse-btn {
                display: block;
            }

            #info-panel {
                max-height: 50vh;
                overflow-y: auto;
            }
        }
    </style>
</head>

<body>
    <div id="container">
        <div id="header">
            <div>
                <h2 style="margin: 0; color: #2c3e50;">ğŸ—ºï¸ Pathfinder Map</h2>
            </div>
            <div>
                <button class="btn btn-secondary" onclick="goHome()">â† ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã«æˆ»ã‚‹</button>
            </div>
        </div>

        <div id="map">
            <div id="attribution" class="attribution">Â© OpenStreetMap contributors</div>
            <div id="info-panel">
                <button class="collapse-btn" onclick="togglePanel()">
                    <span id="toggle-text">â–¼ æƒ…å ±ãƒ‘ãƒãƒ«ã‚’é–‰ã˜ã‚‹</span>
                </button>

                <div class="panel-content" id="panel-content">
                    <div id="user-info">
                        <div class="loading">
                            <div class="spinner"></div>
                            <span>ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’èª­ã¿è¾¼ã¿ä¸­...</span>
                        </div>
                    </div>

                    <div id="data-info" style="margin-top: 15px;">
                        <div class="loading">
                            <div class="spinner"></div>
                            <span>ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­...</span>
                        </div>
                    </div>

                    <!-- Time Filter -->
                    <div id="time-filter-container" style="display: none;">
                        <div class="filter-header">
                            <span>ğŸ“… æœŸé–“æŒ‡å®š</span>
                            <span id="date-range-display">å…¨æœŸé–“</span>
                        </div>

                        <div class="preset-buttons">
                            <button class="preset-btn active" data-range="all">å…¨æœŸé–“</button>
                            <button class="preset-btn" data-range="year">ä»Šå¹´</button>
                            <button class="preset-btn" data-range="month">ç›´è¿‘1ãƒ¶æœˆ</button>
                        </div>

                        <div id="time-slider"></div>
                    </div>

                    <!-- åœ°å›³é¸æŠ -->
                    <div style="margin-top: 15px;">
                        <label style="font-size: 12px; font-weight: bold; color: #2c3e50;">ğŸ—ºï¸ åœ°å›³ã‚¹ã‚¿ã‚¤ãƒ«</label>
                        <select id="map-style"
                            style="width: 100%; padding: 4px; margin-top: 5px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px;">
                            <option value="osm">OpenStreetMap (æ¨™æº–)</option>
                            <option value="white">ç™½åŸºèª¿ (ã‚¯ãƒªãƒ¼ãƒ³)</option>
                            <option value="satellite">è¡›æ˜Ÿç”»åƒ</option>
                        </select>
                    </div>
                </div>
            </div>

            <div id="tooltip"></div>
        </div>
    </div>

    <script>
        class PathfinderMap {
            constructor() {
                this.deck = null;
                this.data = [];
                this.filteredData = []; // ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°å¾Œã®ãƒ‡ãƒ¼ã‚¿
                this.minDate = null;
                this.maxDate = null;
                this.userInfo = null;
                this.token = localStorage.getItem('token');
                this.currentMapStyle = 'osm';
                this.lastZoom = 10; // åˆæœŸã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«
                this.dailyRouteData = null; // æ—¥æ¬¡ãƒ«ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿

                if (!this.token) {
                    alert('ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™');
                    window.location.href = '/';
                    return;
                }

                this.init();
            }

            async init() {
                try {
                    // Check for URL parameter
                    const urlParams = new URLSearchParams(window.location.search);
                    this.targetUser = urlParams.get('user');

                    // Deck.glãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ç¢ºèª
                    if (typeof deck === 'undefined') {
                        throw new Error('Deck.gl library not loaded');
                    }
                    console.log('Deck.gl version:', deck.VERSION);

                    // If viewing another user, title changes
                    if (this.targetUser) {
                        document.title = `Pathfinder - ${this.targetUser}ã®åœ°å›³`;
                    }

                    await this.loadUserInfo();
                    await this.loadData();
                    this.initMap();
                    this.setupEventListeners();
                } catch (error) {
                    console.error('Initialization failed:', error);
                    this.showError('åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
                }
            }

            async loadUserInfo() {
                try {
                    const response = await fetch('/api/auth/profile', {
                        headers: {
                            'Authorization': `Bearer ${this.token}`
                        }
                    });

                    if (!response.ok) {
                        throw new Error('èªè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸ');
                    }

                    this.userInfo = await response.json();
                    this.updateUserInfo();
                } catch (error) {
                    console.error('Failed to load user info:', error);
                    throw error;
                }
            }

            async loadData() {
                try {
                    // Loading all data from API
                    let url = '/api/map/timeline-points';
                    if (this.targetUser) {
                        url += `?target_username=${encodeURIComponent(this.targetUser)}`;
                    }

                    const response = await fetch(url, {
                        headers: {
                            'Authorization': `Bearer ${this.token}`
                        }
                    });

                    if (!response.ok) {
                        console.error('API response error:', response.status, response.statusText);
                        throw new Error('ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
                    }

                    const result = await response.json();

                    // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã®äº‹å‰è¨ˆç®—ã¨ãƒ‡ãƒ¼ã‚¿ã‚»ãƒƒãƒˆ
                    this.data = (result.data || []).map(d => {
                        d.timestamp = new Date(d.time).getTime();
                        return d;
                    });

                    // åˆæœŸçŠ¶æ…‹ã§ã¯å…¨ãƒ‡ãƒ¼ã‚¿è¡¨ç¤º
                    this.filteredData = [...this.data];

                    if (this.data.length > 0) {
                        // æœ€å°ãƒ»æœ€å¤§æ—¥æ™‚ã®è¨ˆç®—
                        let min = Infinity;
                        let max = -Infinity;
                        for (const d of this.data) {
                            if (d.timestamp < min) min = d.timestamp;
                            if (d.timestamp > max) max = d.timestamp;
                        }
                        this.minDate = min;
                        this.maxDate = max;

                        // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
                        this.setupTimeFilter();
                    }

                    this.updateDataInfo(result);

                } catch (error) {
                    console.error('Failed to load data:', error);
                    throw error;
                }
            }

            initMap() {
                // åˆæœŸè¦–ç‚¹ï¼ˆæ—¥æœ¬ã®ä¸­å¿ƒä»˜è¿‘ï¼‰
                const initialViewState = {
                    longitude: 139.6917,
                    latitude: 35.6895,
                    zoom: 10,
                    pitch: 0,
                    bearing: 0
                };

                // ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯ã€ãƒ‡ãƒ¼ã‚¿ã®ä¸­å¿ƒã«ç§»å‹•
                if (this.data.length > 0) {
                    const avgLat = this.data.reduce((sum, d) => sum + d.lat, 0) / this.data.length;
                    const avgLng = this.data.reduce((sum, d) => sum + d.lng, 0) / this.data.length;
                    initialViewState.latitude = avgLat;
                    initialViewState.longitude = avgLng;
                }

                try {
                    // åˆæœŸã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã‚’è¨­å®š
                    this.currentZoom = initialViewState.zoom;
                    this.lastZoom = initialViewState.zoom;

                    // Deck.glã§èƒŒæ™¯åœ°å›³ã‚‚å«ã‚ã¦åˆæœŸåŒ–
                    this.deck = new deck.DeckGL({
                        container: 'map',
                        initialViewState: initialViewState,
                        controller: true,
                        layers: [], // initLayers will set them
                        onHover: this.onHover.bind(this),
                        onClick: this.onClick.bind(this),
                        onViewStateChange: this.onViewStateChange.bind(this)
                    });

                    // æ˜ç¤ºçš„ã«ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ›´æ–°
                    setTimeout(() => {
                        this.updateLayers();
                    }, 100);

                } catch (error) {
                    console.error('Failed to initialize map:', error);
                    this.showError('åœ°å›³ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
                }
            }

            updateLayers() {
                if (!this.deck) return;

                const layers = [
                    this.createTileLayer(),
                    this.createTimelineLayer(),
                    this.createOtherPointsLayer()
                ];

                const pathLayer = this.createPathLayer();
                if (pathLayer) {
                    layers.push(pathLayer);
                }

                this.deck.setProps({
                    layers: layers
                });

                // è¡¨ç¤ºãƒã‚¤ãƒ³ãƒˆæ•°ã‚’æ›´æ–°
                this.updatePointCount(this.createTimelineLayer().props.data.length + this.createOtherPointsLayer().props.data.length);
            }

            createTileLayer() {
                let tileUrl;
                switch (this.currentMapStyle) {
                    case 'satellite':
                        tileUrl = 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}';
                        break;
                    case 'white':
                        tileUrl = 'https://cartodb-basemaps-a.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png';
                        break;
                    case 'osm':
                    default:
                        tileUrl = 'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png';
                        break;
                }

                return new deck.TileLayer({
                    id: 'tile-layer',
                    data: tileUrl,
                    minZoom: 0,
                    maxZoom: 19,
                    tileSize: 256,
                    renderSubLayers: props => {
                        const {
                            bbox: { west, south, east, north }
                        } = props.tile;

                        return new deck.BitmapLayer(props, {
                            data: null,
                            image: props.data,
                            bounds: [west, south, east, north]
                        });
                    }
                });
            }

            createPathLayer() {
                if (!this.dailyRouteData) return null;

                return new deck.PathLayer({
                    id: 'daily-route-path',
                    data: [this.dailyRouteData],
                    pickable: true,
                    widthScale: 1,
                    widthMinPixels: 3,
                    getPath: d => d.path,
                    getColor: [231, 76, 60, 200], // Red
                    getWidth: 5,
                    capRounded: true,
                    jointRounded: true
                });
            }

            updateMapStyle(style) {
                this.currentMapStyle = style;
                this.updateAttribution(style);
                this.updateLayers();
            }

            updateAttribution(style) {
                const attribution = document.getElementById('attribution');
                if (attribution) {
                    switch (style) {
                        case 'satellite':
                            attribution.textContent = 'Â© Esri';
                            break;
                        case 'white':
                            attribution.textContent = 'Â© CartoDB, Â© OpenStreetMap contributors';
                            break;
                        case 'osm':
                        default:
                            attribution.textContent = 'Â© OpenStreetMap contributors';
                            break;
                    }
                }
            }

            setupEventListeners() {
                const mapStyleSelect = document.getElementById('map-style');
                if (mapStyleSelect) {
                    mapStyleSelect.addEventListener('change', (e) => {
                        this.updateMapStyle(e.target.value);
                    });
                }
            }

            setupTimeFilter() {
                const slider = document.getElementById('time-slider');
                const container = document.getElementById('time-filter-container');

                if (!slider || !this.minDate || !this.maxDate) return;

                container.style.display = 'block';

                if (slider.noUiSlider) {
                    slider.noUiSlider.destroy();
                }

                noUiSlider.create(slider, {
                    start: [this.minDate, this.maxDate],
                    connect: true,
                    range: {
                        'min': this.minDate,
                        'max': this.maxDate
                    },
                    step: 24 * 60 * 60 * 1000,
                    format: {
                        to: value => value,
                        from: value => value
                    }
                });

                this.updateDateDisplay(this.minDate, this.maxDate);

                slider.noUiSlider.on('update', (values) => {
                    this.updateDateDisplay(values[0], values[1]);
                });

                slider.noUiSlider.on('set', (values) => {
                    this.applyTimeFilter(parseFloat(values[0]), parseFloat(values[1]));
                });

                document.querySelectorAll('.preset-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');

                        const range = e.target.dataset.range;
                        let start = this.minDate;
                        let end = this.maxDate;

                        if (range === 'month') {
                            const oneMonthAgo = new Date();
                            oneMonthAgo.setMonth(oneMonthAgo.getMonth() - 1);
                            start = Math.max(this.minDate, oneMonthAgo.getTime());
                        } else if (range === 'year') {
                            const startOfYear = new Date(new Date().getFullYear(), 0, 1).getTime();
                            start = Math.max(this.minDate, startOfYear);
                        }

                        slider.noUiSlider.set([start, end]);
                        this.applyTimeFilter(start, end);
                    });
                });
            }

            updateDateDisplay(start, end) {
                const startDate = new Date(parseInt(start)).toLocaleDateString('ja-JP');
                const endDate = new Date(parseInt(end)).toLocaleDateString('ja-JP');
                document.getElementById('date-range-display').textContent = `${startDate} - ${endDate}`;
            }

            applyTimeFilter(start, end) {
                this.filteredData = this.data.filter(d => d.timestamp >= start && d.timestamp <= end);
                this.updateLayers();
            }

            updatePointCount(displayedPoints) {
                const dataInfoElement = document.getElementById('data-info');
                if (!dataInfoElement) return;

                let content = '';

                // Add daily stats if available
                if (this.dailyRouteData) {
                    const data = this.dailyRouteData.stats;
                    const date = new Date(data.date).toLocaleDateString('ja-JP', { year: 'numeric', month: 'long', day: 'numeric', weekday: 'short' });
                     content += `
                        <div style="border-bottom: 1px solid #eee; padding-bottom: 10px; margin-bottom: 10px; background: #fff5f5; padding: 10px; border-radius: 4px;">
                            <div style="font-weight: bold; color: #c0392b;">ğŸ“… ${date} ã®ãƒ«ãƒ¼ãƒˆ</div>
                            <button class="btn btn-secondary" onclick="window.mapInstance.clearRoute()" style="margin-top: 8px; font-size: 12px; padding: 4px 8px; width: 100%;">ãƒ«ãƒ¼ãƒˆè§£é™¤</button>
                        </div>
                    `;
                }

                if (this.data.length > 0) {
                    const totalPoints = this.data.length;
                    const filteredTotal = this.filteredData.length;
                    const percentage = filteredTotal > 0 ? Math.round((displayedPoints / filteredTotal) * 100) : 0;
                    const filterPercentage = totalPoints > 0 ? Math.round((filteredTotal / totalPoints) * 100) : 0;

                    content += `
                        <div><strong>ğŸ“Š ãƒ‡ãƒ¼ã‚¿æƒ…å ±</strong></div>
                        <div>ç·ãƒ‡ãƒ¼ã‚¿æ•°: ${totalPoints.toLocaleString()}</div>
                        <div>æœŸé–“çµè¾¼: ${filteredTotal.toLocaleString()} (${filterPercentage}%)</div>
                        <div>è¡¨ç¤ºä¸­: ${displayedPoints.toLocaleString()} (ã‚ºãƒ¼ãƒ : ${percentage}%)</div>
                        <div class="legend">
                           ${this.getLegendHtml()}
                        </div>
                        ${displayedPoints < totalPoints ?
                            '<div style="font-size: 10px; color: #666; margin-top: 8px;">ğŸ” æ‹¡å¤§ã™ã‚‹ã¨æ›´å¤šã®ãƒã‚¤ãƒ³ãƒˆãŒè¡¨ç¤ºã•ã‚Œã¾ã™</div>' : ''
                        }
                    `;
                } else {
                     content += `
                        <div style="color: #e67e22;">ğŸ“Š ãƒ‡ãƒ¼ã‚¿ãªã—</div>
                        <div style="font-size: 12px; color: #7f8c8d;">ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“</div>
                    `;
                }

                dataInfoElement.innerHTML = content;
            }

            getLegendHtml() {
                return `
                            <div class="legend-item">
                                <div class="legend-color" style="background: #e74c3c;"></div>
                                <span>è¨ªå•åœ°ç‚¹ (visit)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #9b59b6;"></div>
                                <span>æ´»å‹• (activity)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #3498db;"></div>
                                <span>è»Œè·¡ (timeline)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #2ecc71;"></div>
                                <span>ç§»å‹• (move)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #f1c40f;"></div>
                                <span>å ´æ‰€ (place)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #1abc9c;"></div>
                                <span>ãƒ‘ã‚¹ (path)</span>
                            </div>
                `;
            }

            updateUserInfo() {
                const userInfoEl = document.getElementById('user-info');

                let displayUser = this.userInfo.username || 'ãƒ¦ãƒ¼ã‚¶ãƒ¼åæœªè¨­å®š';
                let displayEmail = this.userInfo.email;
                let prefix = 'ğŸ‘¤';

                if (this.targetUser) {
                    displayUser = this.targetUser;
                    displayEmail = 'Viewing Friend\'s Map';
                    prefix = 'ğŸ¤';
                }

                userInfoEl.innerHTML = `
                    <div style="font-weight: bold; color: #2c3e50;">${prefix} ${displayUser}</div>
                    <div style="font-size: 12px; color: #7f8c8d;">${displayEmail}</div>
                `;
            }

            updateDataInfo(result) {
                // Initial load only
                this.updatePointCount(result.data ? result.data.length : 0);
            }

            filterDataByZoom(data, zoom) {
                if (data.length <= 3000) return data;

                let percentage;
                if (zoom <= 8) percentage = 0.5;
                else if (zoom <= 9) percentage = 0.6;
                else if (zoom <= 10) percentage = 0.7;
                else if (zoom <= 11) percentage = 0.8;
                else if (zoom <= 12) percentage = 0.9;
                else if (zoom <= 13) percentage = 0.95;
                else return data;

                const maxPoints = Math.floor(data.length * percentage);
                const step = Math.floor(data.length / maxPoints);
                return data.filter((_, index) => index % step === 0);
            }

            createTimelineLayer() {
                let timelineData = this.filteredData.filter(d =>
                    d.type === 'timeline' || d.type === 'timelinePath'
                );

                const zoom = this.currentZoom || this.lastZoom || 10;
                timelineData = this.filterDataByZoom(timelineData, zoom);

                return new deck.ScatterplotLayer({
                    id: 'timeline-points',
                    data: timelineData,
                    pickable: true,
                    opacity: 0.7,
                    stroked: true,
                    filled: true,
                    radiusScale: 1,
                    radiusMinPixels: 3,
                    radiusMaxPixels: 50,
                    lineWidthMinPixels: 1,
                    getPosition: d => [d.lng, d.lat],
                    getRadius: d => this.getPointRadiusByType(d.type),
                    getFillColor: d => this.getColorByType(d.type),
                    getLineColor: [0, 0, 0, 200],
                    updateTriggers: {
                        getFillColor: timelineData,
                        getPosition: timelineData,
                        getRadius: [this.deck?.viewState?.zoom]
                    }
                });
            }

            createOtherPointsLayer() {
                let otherData = this.filteredData.filter(d =>
                    d.type !== 'timeline' && d.type !== 'timelinePath'
                );

                const zoom = this.currentZoom || this.lastZoom || 10;
                otherData = this.filterDataByZoom(otherData, zoom);

                return new deck.ScatterplotLayer({
                    id: 'other-points',
                    data: otherData,
                    pickable: true,
                    opacity: 0.9,
                    stroked: true,
                    filled: true,
                    radiusScale: 1,
                    radiusMinPixels: 2,
                    radiusMaxPixels: 40,
                    lineWidthMinPixels: 1,
                    getPosition: d => [d.lng, d.lat],
                    getRadius: d => this.getPointRadiusByType(d.type),
                    getFillColor: d => this.getColorByType(d.type),
                    getLineColor: [0, 0, 0, 200],
                    updateTriggers: {
                        getFillColor: otherData,
                        getPosition: otherData,
                        getRadius: [this.deck?.viewState?.zoom]
                    }
                });
            }

            getPointRadiusByType(type) {
                const zoom = this.deck?.viewState?.zoom || 10;
                const isTimeline = type === 'timeline' || type === 'timelinePath';
                let baseRadius;
                if (zoom <= 8) baseRadius = isTimeline ? 40 : 30;
                else if (zoom <= 12) baseRadius = isTimeline ? 25 : 18;
                else if (zoom <= 16) baseRadius = isTimeline ? 15 : 12;
                else baseRadius = isTimeline ? 8 : 6;
                return baseRadius;
            }

            getColorByType(type) {
                switch (type) {
                    case 'visit':
                    case 'placeVisit': return [231, 76, 60, 255];
                    case 'activity':
                    case 'activitySegment': return [155, 89, 182, 255];
                    case 'timeline':
                    case 'timelinePath': return [52, 152, 219, 255];
                    case 'move': return [46, 204, 113, 255];
                    case 'place': return [241, 196, 15, 255];
                    case 'path': return [26, 188, 156, 255];
                    default: return [255, 165, 0, 255];
                }
            }

            onHover(info) {
                const tooltip = document.getElementById('tooltip');
                if (info.object) {
                    const obj = info.object;
                    const date = new Date(obj.time).toLocaleDateString('ja-JP');
                    const time = new Date(obj.time).toLocaleTimeString('ja-JP');
                    let content = `
                        <div><strong>ã‚¿ã‚¤ãƒ—:</strong> ${obj.type}</div>
                        <div><strong>æ—¥æ™‚:</strong> ${date} ${time}</div>
                        <div><strong>åº§æ¨™:</strong> ${obj.lat.toFixed(4)}, ${obj.lng.toFixed(4)}</div>
                    `;
                    if (obj.semantic) content += `<div><strong>å ´æ‰€:</strong> ${obj.semantic}</div>`;
                    if (obj.activity) content += `<div><strong>æ´»å‹•:</strong> ${obj.activity}</div>`;

                    if (obj.path) { // Route path hover?
                        // PathLayer data structure is {path: [[],[]...], date: ...}
                        // info.object refers to this data object.
                         content = `<div><strong>ğŸ“… æ—¥æ¬¡ãƒ«ãƒ¼ãƒˆ</strong></div><div>${obj.date}</div>`;
                    }

                    tooltip.innerHTML = content;
                    tooltip.style.display = 'block';
                    tooltip.style.left = info.x + 'px';
                    tooltip.style.top = info.y + 'px';
                } else {
                    tooltip.style.display = 'none';
                }
            }

            async onClick(info) {
                if (info.object && info.object.time) {
                    const date = new Date(info.object.time);
                    const dateStr = date.toISOString().split('T')[0];
                    console.log('Fetching route for:', dateStr);
                    await this.fetchDailyRoute(dateStr);
                }
            }

            async fetchDailyRoute(dateStr) {
                try {
                    const infoPanel = document.getElementById('data-info');
                    // Simple loading indicator
                    // But we want to preserve layout

                    let url = `/api/map/daily-route?date=${dateStr}`;
                    if (this.targetUser) {
                        url += `&target_username=${encodeURIComponent(this.targetUser)}`;
                    }

                    const response = await fetch(url, {
                        headers: {
                            'Authorization': `Bearer ${this.token}`
                        }
                    });

                    if (!response.ok) throw new Error('ãƒ«ãƒ¼ãƒˆãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');

                    const result = await response.json();

                    if (result.data && result.data.length > 0) {
                        const path = result.data.map(d => [d.lng, d.lat]);
                        this.dailyRouteData = {
                            path: path,
                            date: dateStr,
                            stats: result
                        };
                        this.updateLayers();
                    } else {
                        alert('æŒ‡å®šã•ã‚ŒãŸæ—¥ä»˜ã®ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ');
                    }

                } catch (error) {
                    console.error('Failed to fetch daily route:', error);
                    alert('ã‚¨ãƒ©ãƒ¼: ' + error.message);
                }
            }

            clearRoute() {
                this.dailyRouteData = null;
                this.updateLayers();
            }

            onViewStateChange({ viewState }) {
                this.currentZoom = viewState.zoom;
                const currentZoom = Math.round(viewState.zoom);
                const prevZoom = this.lastZoom || currentZoom;

                if (Math.abs(currentZoom - prevZoom) >= 0.5) {
                    this.lastZoom = currentZoom;
                    if (this.updateTimer) clearTimeout(this.updateTimer);
                    const delay = this.data.length > 50000 ? 300 : 150;
                    this.updateTimer = setTimeout(() => {
                        this.updateLayers();
                    }, delay);
                }
                return viewState;
            }

            showError(message) {
                const dataInfoEl = document.getElementById('data-info');
                dataInfoEl.innerHTML = `
                    <div style="color: #e74c3c;">âŒ ã‚¨ãƒ©ãƒ¼</div>
                    <div style="font-size: 12px; color: #7f8c8d;">${message}</div>
                `;
            }
        }

        function goHome() {
            window.location.href = '/';
        }

        function togglePanel() {
            const panel = document.getElementById('info-panel');
            const toggleText = document.getElementById('toggle-text');
            if (panel.classList.contains('panel-collapsed')) {
                panel.classList.remove('panel-collapsed');
                toggleText.textContent = 'â–¼ æƒ…å ±ãƒ‘ãƒãƒ«ã‚’é–‰ã˜ã‚‹';
            } else {
                panel.classList.add('panel-collapsed');
                toggleText.textContent = 'â–¶ æƒ…å ±ãƒ‘ãƒãƒ«ã‚’é–‹ã';
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            window.mapInstance = new PathfinderMap();
        });
    </script>
</body>

</html>
