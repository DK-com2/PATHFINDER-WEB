<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pathfinder - åœ°å›³è¡¨ç¤º</title>
    
    <!-- Deck.gl CDN -->
    <script src="https://unpkg.com/deck.gl@^8.9.0/dist.min.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Helvetica', 'Arial', sans-serif;
            background: #f5f5f5;
        }
        
        #container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #header {
            background: white;
            padding: 10px 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #map {
            flex: 1;
            position: relative;
        }
        
        #info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            min-width: 200px;
            z-index: 1000;
        }
        
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1001;
            display: none;
        }
        
        .loading {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .spinner {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .legend {
            margin-top: 10px;
            font-size: 12px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 3px 0;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .btn:hover {
            background: #2980b9;
        }
        
        .btn-secondary {
            background: #95a5a6;
        }
        
        .btn-secondary:hover {
            background: #7f8c8d;
        }
        
        .attribution {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            color: #666;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <div>
                <h2 style="margin: 0; color: #2c3e50;">ğŸ—ºï¸ Pathfinder Map</h2>
            </div>
            <div>
                <button class="btn btn-secondary" onclick="goHome()">â† ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã«æˆ»ã‚‹</button>
            </div>
        </div>
        
        <div id="map">
            <div id="attribution" class="attribution">Â© OpenStreetMap contributors</div>
            <div id="info-panel">
                <div id="user-info">
                    <div class="loading">
                        <div class="spinner"></div>
                        <span>ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã‚’èª­ã¿è¾¼ã¿ä¸­...</span>
                    </div>
                </div>
                
                <div id="data-info" style="margin-top: 15px;">
                    <div class="loading">
                        <div class="spinner"></div>
                        <span>ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã¿ä¸­...</span>
                    </div>
                </div>
                
                <!-- åœ°å›³é¸æŠ -->
                <div style="margin-top: 15px;">
                    <label style="font-size: 12px; font-weight: bold; color: #2c3e50;">ğŸ—ºï¸ åœ°å›³ã‚¹ã‚¿ã‚¤ãƒ«</label>
                    <select id="map-style" style="width: 100%; padding: 4px; margin-top: 5px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px;">
                        <option value="osm">OpenStreetMap (æ¨™æº–)</option>
                        <option value="white">ç™½åŸºèª¿ (ã‚¯ãƒªãƒ¼ãƒ³)</option>
                        <option value="satellite">è¡›æ˜Ÿç”»åƒ</option>
                    </select>
                </div>
                
            </div>
            
            <div id="tooltip"></div>
        </div>
    </div>

    <script>
        class PathfinderMap {
            constructor() {
                this.deck = null;
                this.data = [];
                this.userInfo = null;
                this.token = localStorage.getItem('token');
                this.currentMapStyle = 'osm';
                this.lastZoom = 10; // åˆæœŸã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«
                
                if (!this.token) {
                    alert('ãƒ­ã‚°ã‚¤ãƒ³ãŒå¿…è¦ã§ã™');
                    window.location.href = '/';
                    return;
                }
                
                this.init();
            }
            
            async init() {
                try {
                    // Deck.glãƒ©ã‚¤ãƒ–ãƒ©ãƒªã®ç¢ºèª
                    if (typeof deck === 'undefined') {
                        throw new Error('Deck.gl library not loaded');
                    }
                    console.log('Deck.gl version:', deck.VERSION);
                    
                    await this.loadUserInfo();
                    await this.loadData();
                    this.initMap();
                    this.setupEventListeners();
                } catch (error) {
                    console.error('Initialization failed:', error);
                    this.showError('åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
                }
            }
            
            async loadUserInfo() {
                try {
                    const response = await fetch('/api/auth/profile', {
                        headers: {
                            'Authorization': `Bearer ${this.token}`
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error('èªè¨¼ã«å¤±æ•—ã—ã¾ã—ãŸ');
                    }
                    
                    this.userInfo = await response.json();
                    this.updateUserInfo();
                } catch (error) {
                    console.error('Failed to load user info:', error);
                    throw error;
                }
            }
            
            async loadData() {
                try {
                    // Loading all data from API
                    const response = await fetch('/api/map/timeline-points', {
                        headers: {
                            'Authorization': `Bearer ${this.token}`
                        }
                    });
                    
                    if (!response.ok) {
                        console.error('API response error:', response.status, response.statusText);
                        throw new Error('ãƒ‡ãƒ¼ã‚¿ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ');
                    }
                    
                    const result = await response.json();
                    // API response received
                    this.data = result.data || [];
                    // Data points loaded
                    
                    if (this.data.length > 0) {
                        // Data available
                    }
                    
                    this.updateDataInfo(result);
                    
                } catch (error) {
                    console.error('Failed to load data:', error);
                    throw error;
                }
            }
            
            initMap() {
                // Initializing map with data
                
                // åˆæœŸè¦–ç‚¹ï¼ˆæ—¥æœ¬ã®ä¸­å¿ƒä»˜è¿‘ï¼‰
                const initialViewState = {
                    longitude: 139.6917,
                    latitude: 35.6895,
                    zoom: 10,
                    pitch: 0,
                    bearing: 0
                };
                
                // ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯ã€ãƒ‡ãƒ¼ã‚¿ã®ä¸­å¿ƒã«ç§»å‹•
                if (this.data.length > 0) {
                    const avgLat = this.data.reduce((sum, d) => sum + d.lat, 0) / this.data.length;
                    const avgLng = this.data.reduce((sum, d) => sum + d.lng, 0) / this.data.length;
                    initialViewState.latitude = avgLat;
                    initialViewState.longitude = avgLng;
                    // Center map at calculated position
                }
                
                try {
                    // åˆæœŸã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã‚’è¨­å®š
                    this.currentZoom = initialViewState.zoom;
                    this.lastZoom = initialViewState.zoom;
                    
                    // Deck.glã§èƒŒæ™¯åœ°å›³ã‚‚å«ã‚ã¦åˆæœŸåŒ–ï¼ˆLeafletã¯ä½¿ã‚ãªã„ï¼‰
                    this.deck = new deck.DeckGL({
                        container: 'map',
                        initialViewState: initialViewState,
                        controller: true,
                        layers: [
                            this.createTileLayer(), 
                            this.createTimelineLayer(), 
                            this.createOtherPointsLayer()
                        ],
                        onHover: this.onHover.bind(this),
                        onClick: this.onClick.bind(this),
                        onViewStateChange: this.onViewStateChange.bind(this)
                    });
                    
                    // Deck.GL initialized successfully
                    
                    // æ˜ç¤ºçš„ã«ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ›´æ–°
                    setTimeout(() => {
                        // Updating layers for performance
                        const timelineLayer = this.createTimelineLayer();
                        const otherLayer = this.createOtherPointsLayer();
                        
                        this.deck.setProps({
                            layers: [
                                this.createTileLayer(), 
                                timelineLayer, 
                                otherLayer
                            ]
                        });
                        
                        // è¡¨ç¤ºãƒã‚¤ãƒ³ãƒˆæ•°ã‚’æ›´æ–°
                        this.updatePointCount(timelineLayer.props.data.length + otherLayer.props.data.length);
                    }, 100);
                    
                } catch (error) {
                    console.error('Failed to initialize map:', error);
                    this.showError('åœ°å›³ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
                }
            }
            
            createTileLayer() {
                // Deck.glã®TileLayerã§èƒŒæ™¯åœ°å›³ã‚’è¡¨ç¤º
                let tileUrl;
                switch(this.currentMapStyle) {
                    case 'satellite':
                        tileUrl = 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}';
                        break;
                    case 'white':
                        tileUrl = 'https://cartodb-basemaps-a.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png';
                        break;
                    case 'osm':
                    default:
                        tileUrl = 'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png';
                        break;
                }
                
                return new deck.TileLayer({
                    id: 'tile-layer',
                    data: tileUrl,
                    minZoom: 0,
                    maxZoom: 19,
                    tileSize: 256,
                    renderSubLayers: props => {
                        const {
                            bbox: {west, south, east, north}
                        } = props.tile;
                        
                        return new deck.BitmapLayer(props, {
                            data: null,
                            image: props.data,
                            bounds: [west, south, east, north]
                        });
                    }
                });
            }
            
            updateMapStyle(style) {
                this.currentMapStyle = style;
                
                // è‘—ä½œæ¨©è¡¨ç¤ºã‚’æ›´æ–°
                this.updateAttribution(style);
                
                // Deck.glã®ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ›´æ–°
                if (this.deck) {
                    const timelineLayer = this.createTimelineLayer();
                    const otherLayer = this.createOtherPointsLayer();
                    
                    this.deck.setProps({
                        layers: [
                            this.createTileLayer(), 
                            timelineLayer, 
                            otherLayer
                        ]
                    });
                    
                    // è¡¨ç¤ºãƒã‚¤ãƒ³ãƒˆæ•°ã‚’æ›´æ–°
                    this.updatePointCount(timelineLayer.props.data.length + otherLayer.props.data.length);
                    
                    // Map style updated
                }
            }
            
            updateAttribution(style) {
                const attribution = document.getElementById('attribution');
                if (attribution) {
                    switch(style) {
                        case 'satellite':
                            attribution.textContent = 'Â© Esri';
                            break;
                        case 'white':
                            attribution.textContent = 'Â© CartoDB, Â© OpenStreetMap contributors';
                            break;
                        case 'osm':
                        default:
                            attribution.textContent = 'Â© OpenStreetMap contributors';
                            break;
                    }
                }
            }
            
            setupEventListeners() {
                // åœ°å›³ã‚¹ã‚¿ã‚¤ãƒ«å¤‰æ›´
                const mapStyleSelect = document.getElementById('map-style');
                if (mapStyleSelect) {
                    mapStyleSelect.addEventListener('change', (e) => {
                        this.updateMapStyle(e.target.value);
                    });
                }
            }
            
            // è¡¨ç¤ºãƒã‚¤ãƒ³ãƒˆæ•°ã‚’æ›´æ–°
            updatePointCount(displayedPoints) {
                const dataInfoElement = document.getElementById('data-info');
                if (dataInfoElement && this.data.length > 0) {
                    const totalPoints = this.data.length;
                    const percentage = Math.round((displayedPoints / totalPoints) * 100);
                    
                    dataInfoElement.innerHTML = `
                        <div><strong>ğŸ“Š ãƒ‡ãƒ¼ã‚¿æƒ…å ±</strong></div>
                        <div>ç·ãƒ‡ãƒ¼ã‚¿æ•°: ${totalPoints.toLocaleString()}</div>
                        <div>è¡¨ç¤ºä¸­: ${displayedPoints.toLocaleString()} (${percentage}%)</div>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #e74c3c;"></div>
                                <span>è¨ªå•åœ°ç‚¹ (visit)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #9b59b6;"></div>
                                <span>æ´»å‹• (activity)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #3498db;"></div>
                                <span>è»Œè·¡ (timeline)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #2ecc71;"></div>
                                <span>ç§»å‹• (move)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #f1c40f;"></div>
                                <span>å ´æ‰€ (place)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #1abc9c;"></div>
                                <span>ãƒ‘ã‚¹ (path)</span>
                            </div>
                        </div>
                        ${displayedPoints < totalPoints ? 
                            '<div style="font-size: 10px; color: #666; margin-top: 8px;">ğŸ” æ‹¡å¤§ã™ã‚‹ã¨æ›´å¤šã®ãƒã‚¤ãƒ³ãƒˆãŒè¡¨ç¤ºã•ã‚Œã¾ã™</div>' : ''
                        }
                    `;
                }
            }
            
            // ã‚·ãƒ³ãƒ—ãƒ«ãªãƒ‡ãƒ¼ã‚¿é–“å¼•ãé–¢æ•°
            filterDataByZoom(data, zoom) {
                // ãƒ‡ãƒ¼ã‚¿ãŒå°‘ãªã„å ´åˆã¯ãã®ã¾ã¾è¡¨ç¤º
                if (data.length <= 3000) return data;
                
                // ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦ãã‚ç´°ã‹ãé–“å¼•ã
                let percentage;
                if (zoom <= 8) {
                    percentage = 0.5; // 50%
                } else if (zoom <= 9) {
                    percentage = 0.6; // 60%
                } else if (zoom <= 10) {
                    percentage = 0.7; // 70%
                } else if (zoom <= 11) {
                    percentage = 0.8; // 80%
                } else if (zoom <= 12) {
                    percentage = 0.9; // 90%
                } else if (zoom <= 13) {
                    percentage = 0.95; // 95%
                } else {
                    return data; // å…¨ã¦è¡¨ç¤º
                }
                
                const maxPoints = Math.floor(data.length * percentage);
                const step = Math.floor(data.length / maxPoints);
                const result = data.filter((_, index) => index % step === 0);
                
                console.log(`Zoom: ${zoom.toFixed(1)}, Showing: ${result.length}/${data.length} (${Math.round((result.length/data.length)*100)}%)`);
                
                return result;
            }
            
            createTimelineLayer() {
                // timelineã¨timelinePathã®ã¿ã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
                let timelineData = this.data.filter(d => 
                    d.type === 'timeline' || d.type === 'timelinePath'
                );
                
                // ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦ãƒ‡ãƒ¼ã‚¿ã‚’é–“å¼•ãï¼ˆcurrentZoomã‚’ä½¿ç”¨ï¼‰
                const zoom = this.currentZoom || this.lastZoom || 10;
                timelineData = this.filterDataByZoom(timelineData, zoom);
                
                // Creating Timeline Layer

                return new deck.ScatterplotLayer({
                    id: 'timeline-points',
                    data: timelineData,
                    pickable: true,
                    opacity: 0.7, // timelineã¯å°‘ã—è–„ã
                    stroked: true,
                    filled: true,
                    radiusScale: 1,
                    radiusMinPixels: 3,
                    radiusMaxPixels: 50,
                    lineWidthMinPixels: 1,
                    getPosition: d => {
                        const pos = [d.lng, d.lat];
                        return pos;
                    },
                    getRadius: d => this.getPointRadiusByType(d.type),
                    getFillColor: d => this.getColorByType(d.type),
                    getLineColor: [0, 0, 0, 200],
                    updateTriggers: {
                        getFillColor: timelineData,
                        getPosition: timelineData,
                        getRadius: [this.deck?.viewState?.zoom]
                    }
                });
            }
            
            createOtherPointsLayer() {
                // timelineä»¥å¤–ã®ãƒã‚¤ãƒ³ãƒˆã‚’ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
                let otherData = this.data.filter(d => 
                    d.type !== 'timeline' && d.type !== 'timelinePath'
                );
                
                // ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦ãƒ‡ãƒ¼ã‚¿ã‚’é–“å¼•ãï¼ˆcurrentZoomã‚’ä½¿ç”¨ï¼‰
                const zoom = this.currentZoom || this.lastZoom || 10;
                otherData = this.filterDataByZoom(otherData, zoom);
                
                // Creating Other Points Layer

                return new deck.ScatterplotLayer({
                    id: 'other-points',
                    data: otherData,
                    pickable: true,
                    opacity: 0.9, // timelineä»¥å¤–ã¯æ¿ƒãè¡¨ç¤ºã—ã¦ç›®ç«‹ãŸã›ã‚‹
                    stroked: true,
                    filled: true,
                    radiusScale: 1,
                    radiusMinPixels: 2, // timelineä»¥å¤–ã¯å°ã•ã‚ã®æœ€å°ã‚µã‚¤ã‚º
                    radiusMaxPixels: 40, // timelineä»¥å¤–ã¯å°ã•ã‚ã®æœ€å¤§ã‚µã‚¤ã‚º
                    lineWidthMinPixels: 1,
                    getPosition: d => {
                        const pos = [d.lng, d.lat];
                        return pos;
                    },
                    getRadius: d => this.getPointRadiusByType(d.type),
                    getFillColor: d => this.getColorByType(d.type),
                    getLineColor: [0, 0, 0, 200],
                    updateTriggers: {
                        getFillColor: otherData,
                        getPosition: otherData,
                        getRadius: [this.deck?.viewState?.zoom]
                    }
                });
            }
            
            getPointRadiusByType(type) {
                // ç¾åœ¨ã®ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã‚’å–å¾—
                const zoom = this.deck?.viewState?.zoom || 10;
                
                // ã‚¿ã‚¤ãƒ—ã”ã¨ã«ã‚µã‚¤ã‚ºèª¿æ•´
                const isTimeline = type === 'timeline' || type === 'timelinePath';
                
                // ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦ãƒã‚¤ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’èª¿æ•´
                let baseRadius;
                if (zoom <= 8) {
                    baseRadius = isTimeline ? 40 : 30; // timelineä»¥å¤–ã¯å°ã•ã
                } else if (zoom <= 12) {
                    baseRadius = isTimeline ? 25 : 18; // timelineä»¥å¤–ã¯å°ã•ã
                } else if (zoom <= 16) {
                    baseRadius = isTimeline ? 15 : 12; // timelineä»¥å¤–ã¯å°ã•ã
                } else {
                    baseRadius = isTimeline ? 8 : 6; // timelineä»¥å¤–ã¯å°ã•ã
                }
                
                return baseRadius;
            }
            
            getColorByType(type) {
                // console.log removed for performance
                switch (type) {
                    case 'visit':
                    case 'placeVisit':
                        return [231, 76, 60, 255]; // èµ¤
                    case 'activity':
                    case 'activitySegment':
                        return [155, 89, 182, 255]; // ç´«ï¼ˆæ´»å‹•ï¼‰
                    case 'timeline':
                    case 'timelinePath':
                        return [52, 152, 219, 255]; // é’ï¼ˆè¦æ±‚é€šã‚Šï¼‰
                    case 'move':
                        return [46, 204, 113, 255]; // ç·‘ï¼ˆç§»å‹•ï¼‰
                    case 'place':
                        return [241, 196, 15, 255]; // é»„è‰²ï¼ˆå ´æ‰€ï¼‰
                    case 'path':
                        return [26, 188, 156, 255]; // ãƒ†ã‚£ãƒ¼ãƒ«ï¼ˆãƒ‘ã‚¹ï¼‰
                    default:
                        // Unknown type, using default color
                        return [255, 165, 0, 255]; // ã‚ªãƒ¬ãƒ³ã‚¸ï¼ˆæœªçŸ¥ã®ã‚¿ã‚¤ãƒ—ï¼‰
                }
            }
            
            onHover(info) {
                const tooltip = document.getElementById('tooltip');
                
                if (info.object) {
                    const obj = info.object;
                    const date = new Date(obj.time).toLocaleDateString('ja-JP');
                    const time = new Date(obj.time).toLocaleTimeString('ja-JP');
                    
                    let content = `
                        <div><strong>ã‚¿ã‚¤ãƒ—:</strong> ${obj.type}</div>
                        <div><strong>æ—¥æ™‚:</strong> ${date} ${time}</div>
                        <div><strong>åº§æ¨™:</strong> ${obj.lat.toFixed(4)}, ${obj.lng.toFixed(4)}</div>
                    `;
                    
                    if (obj.semantic) {
                        content += `<div><strong>å ´æ‰€:</strong> ${obj.semantic}</div>`;
                    }
                    
                    if (obj.activity) {
                        content += `<div><strong>æ´»å‹•:</strong> ${obj.activity}</div>`;
                    }
                    
                    tooltip.innerHTML = content;
                    tooltip.style.display = 'block';
                    tooltip.style.left = info.x + 'px';
                    tooltip.style.top = info.y + 'px';
                } else {
                    tooltip.style.display = 'none';
                }
            }
            
            onClick(info) {
                if (info.object) {
                    console.log('Clicked object:', info.object);
                }
            }
            
            onViewStateChange({viewState}) {
                // ç¾åœ¨ã®ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ã‚’ä¿å­˜ï¼ˆå°æ•°ç‚¹ã‚‚å«ã‚€ï¼‰
                this.currentZoom = viewState.zoom;
                
                // ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ãŒå¤‰ã‚ã£ãŸã¨ãã«ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ›´æ–°
                const currentZoom = Math.round(viewState.zoom);
                const prevZoom = this.lastZoom || currentZoom;
                
                if (Math.abs(currentZoom - prevZoom) >= 0.5) { // ã‚ºãƒ¼ãƒ ãƒ¬ãƒ™ãƒ«ãŒ0.5ä»¥ä¸Šå¤‰ã‚ã£ãŸæ™‚ã«æ›´æ–°
                    this.lastZoom = currentZoom;
                    
                    // ãƒ‡ãƒã‚¦ãƒ³ã‚¹å‡¦ç† - æ—¢å­˜ã®ã‚¿ã‚¤ãƒãƒ¼ã‚’ã‚¯ãƒªã‚¢
                    if (this.updateTimer) {
                        clearTimeout(this.updateTimer);
                    }
                    
                    // å¤§é‡ãƒ‡ãƒ¼ã‚¿ã®å ´åˆã€æ›´æ–°ã‚’å°‘ã—é…å»¶ã•ã›ã¦ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Š
                    const delay = this.data.length > 50000 ? 300 : 150; // é…å»¶ã‚’èª¿æ•´
                    
                    // ãƒã‚¤ãƒ³ãƒˆã‚µã‚¤ã‚ºã‚’æ›´æ–°ã™ã‚‹ãŸã‚ã«ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å†ä½œæˆ
                    this.updateTimer = setTimeout(() => {
                        if (this.deck) {
                            const timelineLayer = this.createTimelineLayer();
                            const otherLayer = this.createOtherPointsLayer();
                            
                            this.deck.setProps({
                                layers: [
                                    this.createTileLayer(), 
                                    timelineLayer, 
                                    otherLayer
                                ]
                            });
                            
                            // è¡¨ç¤ºãƒã‚¤ãƒ³ãƒˆæ•°ã‚’æ›´æ–°
                            this.updatePointCount(timelineLayer.props.data.length + otherLayer.props.data.length);
                        }
                    }, delay);
                }
                
                return viewState;
            }
            
            updateUserInfo() {
                const userInfoEl = document.getElementById('user-info');
                userInfoEl.innerHTML = `
                    <div style="font-weight: bold; color: #2c3e50;">ğŸ‘¤ ${this.userInfo.username || 'ãƒ¦ãƒ¼ã‚¶ãƒ¼åæœªè¨­å®š'}</div>
                    <div style="font-size: 12px; color: #7f8c8d;">${this.userInfo.email}</div>
                `;
            }
            
            updateDataInfo(result) {
                const dataInfoEl = document.getElementById('data-info');
                
                if (result.total === 0) {
                    dataInfoEl.innerHTML = `
                        <div style="color: #e67e22;">ğŸ“Š ãƒ‡ãƒ¼ã‚¿ãªã—</div>
                        <div style="font-size: 12px; color: #7f8c8d;">ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“</div>
                    `;
                } else {
                    dataInfoEl.innerHTML = `
                        <div style="font-weight: bold; color: #27ae60;">ğŸ“Š ${result.total.toLocaleString()} ãƒã‚¤ãƒ³ãƒˆ</div>
                        <div style="font-size: 12px; color: #7f8c8d;">å…¨ãƒ‡ãƒ¼ã‚¿ã‚’åœ°å›³ä¸Šã«è¡¨ç¤ºä¸­</div>
                    `;
                }
            }
            
            showError(message) {
                const dataInfoEl = document.getElementById('data-info');
                dataInfoEl.innerHTML = `
                    <div style="color: #e74c3c;">âŒ ã‚¨ãƒ©ãƒ¼</div>
                    <div style="font-size: 12px; color: #7f8c8d;">${message}</div>
                `;
            }
        }
        
        function goHome() {
            window.location.href = '/';
        }
        
        // ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³èµ·å‹•
        document.addEventListener('DOMContentLoaded', () => {
            new PathfinderMap();
        });
    </script>
</body>
</html>