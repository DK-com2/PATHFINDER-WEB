<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pathfinder - 地図表示</title>
    
    <!-- Deck.gl CDN -->
    <script src="https://unpkg.com/deck.gl@^8.9.0/dist.min.js"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Helvetica', 'Arial', sans-serif;
            background: #f5f5f5;
        }
        
        #container {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        #header {
            background: white;
            padding: 10px 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #map {
            flex: 1;
            position: relative;
        }
        
        #info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
            min-width: 200px;
            z-index: 1000;
        }
        
        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1001;
            display: none;
        }
        
        .loading {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .spinner {
            border: 2px solid #f3f3f3;
            border-top: 2px solid #3498db;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .legend {
            margin-top: 10px;
            font-size: 12px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 3px 0;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        .btn:hover {
            background: #2980b9;
        }
        
        .btn-secondary {
            background: #95a5a6;
        }
        
        .btn-secondary:hover {
            background: #7f8c8d;
        }
        
        .attribution {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            color: #666;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <div>
                <h2 style="margin: 0; color: #2c3e50;">🗺️ Pathfinder Map</h2>
            </div>
            <div>
                <button class="btn btn-secondary" onclick="goHome()">← ダッシュボードに戻る</button>
            </div>
        </div>
        
        <div id="map">
            <div id="attribution" class="attribution">© OpenStreetMap contributors</div>
            <div id="info-panel">
                <div id="user-info">
                    <div class="loading">
                        <div class="spinner"></div>
                        <span>ユーザー情報を読み込み中...</span>
                    </div>
                </div>
                
                <div id="data-info" style="margin-top: 15px;">
                    <div class="loading">
                        <div class="spinner"></div>
                        <span>データを読み込み中...</span>
                    </div>
                </div>
                
                <!-- 地図選択 -->
                <div style="margin-top: 15px;">
                    <label style="font-size: 12px; font-weight: bold; color: #2c3e50;">🗺️ 地図スタイル</label>
                    <select id="map-style" style="width: 100%; padding: 4px; margin-top: 5px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px;">
                        <option value="osm">OpenStreetMap (標準)</option>
                        <option value="white">白基調 (クリーン)</option>
                        <option value="satellite">衛星画像</option>
                    </select>
                </div>
                
            </div>
            
            <div id="tooltip"></div>
        </div>
    </div>

    <script>
        class PathfinderMap {
            constructor() {
                this.deck = null;
                this.data = [];
                this.userInfo = null;
                this.token = localStorage.getItem('token');
                this.currentMapStyle = 'osm';
                this.lastZoom = 10; // 初期ズームレベル
                
                if (!this.token) {
                    alert('ログインが必要です');
                    window.location.href = '/';
                    return;
                }
                
                this.init();
            }
            
            async init() {
                try {
                    // Deck.glライブラリの確認
                    if (typeof deck === 'undefined') {
                        throw new Error('Deck.gl library not loaded');
                    }
                    console.log('Deck.gl version:', deck.VERSION);
                    
                    await this.loadUserInfo();
                    await this.loadData();
                    this.initMap();
                    this.setupEventListeners();
                } catch (error) {
                    console.error('Initialization failed:', error);
                    this.showError('初期化に失敗しました: ' + error.message);
                }
            }
            
            async loadUserInfo() {
                try {
                    const response = await fetch('/api/auth/profile', {
                        headers: {
                            'Authorization': `Bearer ${this.token}`
                        }
                    });
                    
                    if (!response.ok) {
                        throw new Error('認証に失敗しました');
                    }
                    
                    this.userInfo = await response.json();
                    this.updateUserInfo();
                } catch (error) {
                    console.error('Failed to load user info:', error);
                    throw error;
                }
            }
            
            async loadData() {
                try {
                    // Loading all data from API
                    const response = await fetch('/api/map/timeline-points', {
                        headers: {
                            'Authorization': `Bearer ${this.token}`
                        }
                    });
                    
                    if (!response.ok) {
                        console.error('API response error:', response.status, response.statusText);
                        throw new Error('データの取得に失敗しました');
                    }
                    
                    const result = await response.json();
                    // API response received
                    this.data = result.data || [];
                    // Data points loaded
                    
                    if (this.data.length > 0) {
                        // Data available
                    }
                    
                    this.updateDataInfo(result);
                    
                } catch (error) {
                    console.error('Failed to load data:', error);
                    throw error;
                }
            }
            
            initMap() {
                // Initializing map with data
                
                // 初期視点（日本の中心付近）
                const initialViewState = {
                    longitude: 139.6917,
                    latitude: 35.6895,
                    zoom: 10,
                    pitch: 0,
                    bearing: 0
                };
                
                // データがある場合は、データの中心に移動
                if (this.data.length > 0) {
                    const avgLat = this.data.reduce((sum, d) => sum + d.lat, 0) / this.data.length;
                    const avgLng = this.data.reduce((sum, d) => sum + d.lng, 0) / this.data.length;
                    initialViewState.latitude = avgLat;
                    initialViewState.longitude = avgLng;
                    // Center map at calculated position
                }
                
                try {
                    // 初期ズームレベルを設定
                    this.currentZoom = initialViewState.zoom;
                    this.lastZoom = initialViewState.zoom;
                    
                    // Deck.glで背景地図も含めて初期化（Leafletは使わない）
                    this.deck = new deck.DeckGL({
                        container: 'map',
                        initialViewState: initialViewState,
                        controller: true,
                        layers: [
                            this.createTileLayer(), 
                            this.createTimelineLayer(), 
                            this.createOtherPointsLayer()
                        ],
                        onHover: this.onHover.bind(this),
                        onClick: this.onClick.bind(this),
                        onViewStateChange: this.onViewStateChange.bind(this)
                    });
                    
                    // Deck.GL initialized successfully
                    
                    // 明示的にレイヤーを更新
                    setTimeout(() => {
                        // Updating layers for performance
                        const timelineLayer = this.createTimelineLayer();
                        const otherLayer = this.createOtherPointsLayer();
                        
                        this.deck.setProps({
                            layers: [
                                this.createTileLayer(), 
                                timelineLayer, 
                                otherLayer
                            ]
                        });
                        
                        // 表示ポイント数を更新
                        this.updatePointCount(timelineLayer.props.data.length + otherLayer.props.data.length);
                    }, 100);
                    
                } catch (error) {
                    console.error('Failed to initialize map:', error);
                    this.showError('地図の初期化に失敗しました: ' + error.message);
                }
            }
            
            createTileLayer() {
                // Deck.glのTileLayerで背景地図を表示
                let tileUrl;
                switch(this.currentMapStyle) {
                    case 'satellite':
                        tileUrl = 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}';
                        break;
                    case 'white':
                        tileUrl = 'https://cartodb-basemaps-a.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png';
                        break;
                    case 'osm':
                    default:
                        tileUrl = 'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png';
                        break;
                }
                
                return new deck.TileLayer({
                    id: 'tile-layer',
                    data: tileUrl,
                    minZoom: 0,
                    maxZoom: 19,
                    tileSize: 256,
                    renderSubLayers: props => {
                        const {
                            bbox: {west, south, east, north}
                        } = props.tile;
                        
                        return new deck.BitmapLayer(props, {
                            data: null,
                            image: props.data,
                            bounds: [west, south, east, north]
                        });
                    }
                });
            }
            
            updateMapStyle(style) {
                this.currentMapStyle = style;
                
                // 著作権表示を更新
                this.updateAttribution(style);
                
                // Deck.glのレイヤーを更新
                if (this.deck) {
                    const timelineLayer = this.createTimelineLayer();
                    const otherLayer = this.createOtherPointsLayer();
                    
                    this.deck.setProps({
                        layers: [
                            this.createTileLayer(), 
                            timelineLayer, 
                            otherLayer
                        ]
                    });
                    
                    // 表示ポイント数を更新
                    this.updatePointCount(timelineLayer.props.data.length + otherLayer.props.data.length);
                    
                    // Map style updated
                }
            }
            
            updateAttribution(style) {
                const attribution = document.getElementById('attribution');
                if (attribution) {
                    switch(style) {
                        case 'satellite':
                            attribution.textContent = '© Esri';
                            break;
                        case 'white':
                            attribution.textContent = '© CartoDB, © OpenStreetMap contributors';
                            break;
                        case 'osm':
                        default:
                            attribution.textContent = '© OpenStreetMap contributors';
                            break;
                    }
                }
            }
            
            setupEventListeners() {
                // 地図スタイル変更
                const mapStyleSelect = document.getElementById('map-style');
                if (mapStyleSelect) {
                    mapStyleSelect.addEventListener('change', (e) => {
                        this.updateMapStyle(e.target.value);
                    });
                }
            }
            
            // 表示ポイント数を更新
            updatePointCount(displayedPoints) {
                const dataInfoElement = document.getElementById('data-info');
                if (dataInfoElement && this.data.length > 0) {
                    const totalPoints = this.data.length;
                    const percentage = Math.round((displayedPoints / totalPoints) * 100);
                    
                    dataInfoElement.innerHTML = `
                        <div><strong>📊 データ情報</strong></div>
                        <div>総データ数: ${totalPoints.toLocaleString()}</div>
                        <div>表示中: ${displayedPoints.toLocaleString()} (${percentage}%)</div>
                        <div class="legend">
                            <div class="legend-item">
                                <div class="legend-color" style="background: #e74c3c;"></div>
                                <span>訪問地点 (visit)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #9b59b6;"></div>
                                <span>活動 (activity)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #3498db;"></div>
                                <span>軌跡 (timeline)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #2ecc71;"></div>
                                <span>移動 (move)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #f1c40f;"></div>
                                <span>場所 (place)</span>
                            </div>
                            <div class="legend-item">
                                <div class="legend-color" style="background: #1abc9c;"></div>
                                <span>パス (path)</span>
                            </div>
                        </div>
                        ${displayedPoints < totalPoints ? 
                            '<div style="font-size: 10px; color: #666; margin-top: 8px;">🔍 拡大すると更多のポイントが表示されます</div>' : ''
                        }
                    `;
                }
            }
            
            // シンプルなデータ間引き関数
            filterDataByZoom(data, zoom) {
                // データが少ない場合はそのまま表示
                if (data.length <= 3000) return data;
                
                // ズームレベルに応じてきめ細かく間引き
                let percentage;
                if (zoom <= 8) {
                    percentage = 0.5; // 50%
                } else if (zoom <= 9) {
                    percentage = 0.6; // 60%
                } else if (zoom <= 10) {
                    percentage = 0.7; // 70%
                } else if (zoom <= 11) {
                    percentage = 0.8; // 80%
                } else if (zoom <= 12) {
                    percentage = 0.9; // 90%
                } else if (zoom <= 13) {
                    percentage = 0.95; // 95%
                } else {
                    return data; // 全て表示
                }
                
                const maxPoints = Math.floor(data.length * percentage);
                const step = Math.floor(data.length / maxPoints);
                const result = data.filter((_, index) => index % step === 0);
                
                console.log(`Zoom: ${zoom.toFixed(1)}, Showing: ${result.length}/${data.length} (${Math.round((result.length/data.length)*100)}%)`);
                
                return result;
            }
            
            createTimelineLayer() {
                // timelineとtimelinePathのみをフィルタリング
                let timelineData = this.data.filter(d => 
                    d.type === 'timeline' || d.type === 'timelinePath'
                );
                
                // ズームレベルに応じてデータを間引き（currentZoomを使用）
                const zoom = this.currentZoom || this.lastZoom || 10;
                timelineData = this.filterDataByZoom(timelineData, zoom);
                
                // Creating Timeline Layer

                return new deck.ScatterplotLayer({
                    id: 'timeline-points',
                    data: timelineData,
                    pickable: true,
                    opacity: 0.7, // timelineは少し薄く
                    stroked: true,
                    filled: true,
                    radiusScale: 1,
                    radiusMinPixels: 3,
                    radiusMaxPixels: 50,
                    lineWidthMinPixels: 1,
                    getPosition: d => {
                        const pos = [d.lng, d.lat];
                        return pos;
                    },
                    getRadius: d => this.getPointRadiusByType(d.type),
                    getFillColor: d => this.getColorByType(d.type),
                    getLineColor: [0, 0, 0, 200],
                    updateTriggers: {
                        getFillColor: timelineData,
                        getPosition: timelineData,
                        getRadius: [this.deck?.viewState?.zoom]
                    }
                });
            }
            
            createOtherPointsLayer() {
                // timeline以外のポイントをフィルタリング
                let otherData = this.data.filter(d => 
                    d.type !== 'timeline' && d.type !== 'timelinePath'
                );
                
                // ズームレベルに応じてデータを間引き（currentZoomを使用）
                const zoom = this.currentZoom || this.lastZoom || 10;
                otherData = this.filterDataByZoom(otherData, zoom);
                
                // Creating Other Points Layer

                return new deck.ScatterplotLayer({
                    id: 'other-points',
                    data: otherData,
                    pickable: true,
                    opacity: 0.9, // timeline以外は濃く表示して目立たせる
                    stroked: true,
                    filled: true,
                    radiusScale: 1,
                    radiusMinPixels: 2, // timeline以外は小さめの最小サイズ
                    radiusMaxPixels: 40, // timeline以外は小さめの最大サイズ
                    lineWidthMinPixels: 1,
                    getPosition: d => {
                        const pos = [d.lng, d.lat];
                        return pos;
                    },
                    getRadius: d => this.getPointRadiusByType(d.type),
                    getFillColor: d => this.getColorByType(d.type),
                    getLineColor: [0, 0, 0, 200],
                    updateTriggers: {
                        getFillColor: otherData,
                        getPosition: otherData,
                        getRadius: [this.deck?.viewState?.zoom]
                    }
                });
            }
            
            getPointRadiusByType(type) {
                // 現在のズームレベルを取得
                const zoom = this.deck?.viewState?.zoom || 10;
                
                // タイプごとにサイズ調整
                const isTimeline = type === 'timeline' || type === 'timelinePath';
                
                // ズームレベルに応じてポイントサイズを調整
                let baseRadius;
                if (zoom <= 8) {
                    baseRadius = isTimeline ? 40 : 30; // timeline以外は小さく
                } else if (zoom <= 12) {
                    baseRadius = isTimeline ? 25 : 18; // timeline以外は小さく
                } else if (zoom <= 16) {
                    baseRadius = isTimeline ? 15 : 12; // timeline以外は小さく
                } else {
                    baseRadius = isTimeline ? 8 : 6; // timeline以外は小さく
                }
                
                return baseRadius;
            }
            
            getColorByType(type) {
                // console.log removed for performance
                switch (type) {
                    case 'visit':
                    case 'placeVisit':
                        return [231, 76, 60, 255]; // 赤
                    case 'activity':
                    case 'activitySegment':
                        return [155, 89, 182, 255]; // 紫（活動）
                    case 'timeline':
                    case 'timelinePath':
                        return [52, 152, 219, 255]; // 青（要求通り）
                    case 'move':
                        return [46, 204, 113, 255]; // 緑（移動）
                    case 'place':
                        return [241, 196, 15, 255]; // 黄色（場所）
                    case 'path':
                        return [26, 188, 156, 255]; // ティール（パス）
                    default:
                        // Unknown type, using default color
                        return [255, 165, 0, 255]; // オレンジ（未知のタイプ）
                }
            }
            
            onHover(info) {
                const tooltip = document.getElementById('tooltip');
                
                if (info.object) {
                    const obj = info.object;
                    const date = new Date(obj.time).toLocaleDateString('ja-JP');
                    const time = new Date(obj.time).toLocaleTimeString('ja-JP');
                    
                    let content = `
                        <div><strong>タイプ:</strong> ${obj.type}</div>
                        <div><strong>日時:</strong> ${date} ${time}</div>
                        <div><strong>座標:</strong> ${obj.lat.toFixed(4)}, ${obj.lng.toFixed(4)}</div>
                    `;
                    
                    if (obj.semantic) {
                        content += `<div><strong>場所:</strong> ${obj.semantic}</div>`;
                    }
                    
                    if (obj.activity) {
                        content += `<div><strong>活動:</strong> ${obj.activity}</div>`;
                    }
                    
                    tooltip.innerHTML = content;
                    tooltip.style.display = 'block';
                    tooltip.style.left = info.x + 'px';
                    tooltip.style.top = info.y + 'px';
                } else {
                    tooltip.style.display = 'none';
                }
            }
            
            onClick(info) {
                if (info.object) {
                    console.log('Clicked object:', info.object);
                }
            }
            
            onViewStateChange({viewState}) {
                // 現在のズームレベルを保存（小数点も含む）
                this.currentZoom = viewState.zoom;
                
                // ズームレベルが変わったときにレイヤーを更新
                const currentZoom = Math.round(viewState.zoom);
                const prevZoom = this.lastZoom || currentZoom;
                
                if (Math.abs(currentZoom - prevZoom) >= 0.5) { // ズームレベルが0.5以上変わった時に更新
                    this.lastZoom = currentZoom;
                    
                    // デバウンス処理 - 既存のタイマーをクリア
                    if (this.updateTimer) {
                        clearTimeout(this.updateTimer);
                    }
                    
                    // 大量データの場合、更新を少し遅延させてパフォーマンス向上
                    const delay = this.data.length > 50000 ? 300 : 150; // 遅延を調整
                    
                    // ポイントサイズを更新するためにレイヤーを再作成
                    this.updateTimer = setTimeout(() => {
                        if (this.deck) {
                            const timelineLayer = this.createTimelineLayer();
                            const otherLayer = this.createOtherPointsLayer();
                            
                            this.deck.setProps({
                                layers: [
                                    this.createTileLayer(), 
                                    timelineLayer, 
                                    otherLayer
                                ]
                            });
                            
                            // 表示ポイント数を更新
                            this.updatePointCount(timelineLayer.props.data.length + otherLayer.props.data.length);
                        }
                    }, delay);
                }
                
                return viewState;
            }
            
            updateUserInfo() {
                const userInfoEl = document.getElementById('user-info');
                userInfoEl.innerHTML = `
                    <div style="font-weight: bold; color: #2c3e50;">👤 ${this.userInfo.username || 'ユーザー名未設定'}</div>
                    <div style="font-size: 12px; color: #7f8c8d;">${this.userInfo.email}</div>
                `;
            }
            
            updateDataInfo(result) {
                const dataInfoEl = document.getElementById('data-info');
                
                if (result.total === 0) {
                    dataInfoEl.innerHTML = `
                        <div style="color: #e67e22;">📊 データなし</div>
                        <div style="font-size: 12px; color: #7f8c8d;">タイムラインデータが見つかりません</div>
                    `;
                } else {
                    dataInfoEl.innerHTML = `
                        <div style="font-weight: bold; color: #27ae60;">📊 ${result.total.toLocaleString()} ポイント</div>
                        <div style="font-size: 12px; color: #7f8c8d;">全データを地図上に表示中</div>
                    `;
                }
            }
            
            showError(message) {
                const dataInfoEl = document.getElementById('data-info');
                dataInfoEl.innerHTML = `
                    <div style="color: #e74c3c;">❌ エラー</div>
                    <div style="font-size: 12px; color: #7f8c8d;">${message}</div>
                `;
            }
        }
        
        function goHome() {
            window.location.href = '/';
        }
        
        // アプリケーション起動
        document.addEventListener('DOMContentLoaded', () => {
            new PathfinderMap();
        });
    </script>
</body>
</html>